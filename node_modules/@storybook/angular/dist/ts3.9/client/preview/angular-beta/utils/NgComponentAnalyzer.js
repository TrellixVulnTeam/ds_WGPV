"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComponentDecoratorMetadata = exports.getComponentPropsDecoratorMetadata = exports.isComponent = exports.isDeclarable = exports.getComponentInputsOutputs = void 0;
const core_1 = require("@angular/core");
const reflectionCapabilities = new core_1.ÉµReflectionCapabilities();
/**
 * Returns component Inputs / Outputs by browsing these properties and decorator
 */
exports.getComponentInputsOutputs = (component) => {
    const componentMetadata = exports.getComponentDecoratorMetadata(component);
    const componentPropsMetadata = exports.getComponentPropsDecoratorMetadata(component);
    const initialValue = {
        inputs: [],
        outputs: [],
    };
    // Adds the I/O present in @Component metadata
    if (componentMetadata && componentMetadata.inputs) {
        initialValue.inputs.push(...componentMetadata.inputs.map((i) => ({ propName: i, templateName: i })));
    }
    if (componentMetadata && componentMetadata.outputs) {
        initialValue.outputs.push(...componentMetadata.outputs.map((i) => ({ propName: i, templateName: i })));
    }
    if (!componentPropsMetadata) {
        return initialValue;
    }
    // Browses component properties to extract I/O
    // Filters properties that have the same name as the one present in the @Component property
    return Object.entries(componentPropsMetadata).reduce((previousValue, [propertyName, values]) => {
        var _a, _b;
        const value = values.find((v) => v instanceof core_1.Input || v instanceof core_1.Output);
        if (value instanceof core_1.Input) {
            const inputToAdd = {
                propName: propertyName,
                templateName: (_a = value.bindingPropertyName) !== null && _a !== void 0 ? _a : propertyName,
            };
            const previousInputsFiltered = previousValue.inputs.filter((i) => i.templateName !== propertyName);
            return Object.assign(Object.assign({}, previousValue), { inputs: [...previousInputsFiltered, inputToAdd] });
        }
        if (value instanceof core_1.Output) {
            const outputToAdd = {
                propName: propertyName,
                templateName: (_b = value.bindingPropertyName) !== null && _b !== void 0 ? _b : propertyName,
            };
            const previousOutputsFiltered = previousValue.outputs.filter((i) => i.templateName !== propertyName);
            return Object.assign(Object.assign({}, previousValue), { outputs: [...previousOutputsFiltered, outputToAdd] });
        }
        return previousValue;
    }, initialValue);
};
exports.isDeclarable = (component) => {
    if (!component) {
        return false;
    }
    const decorators = reflectionCapabilities.annotations(component);
    return !!(decorators || []).find((d) => d instanceof core_1.Directive || d instanceof core_1.Pipe || d instanceof core_1.Component);
};
exports.isComponent = (component) => {
    if (!component) {
        return false;
    }
    const decorators = reflectionCapabilities.annotations(component);
    return (decorators || []).some((d) => d instanceof core_1.Component);
};
/**
 * Returns all component decorator properties
 * is used to get all `@Input` and `@Output` Decorator
 */
exports.getComponentPropsDecoratorMetadata = (component) => {
    return reflectionCapabilities.propMetadata(component);
};
/**
 * Returns component decorator `@Component`
 */
exports.getComponentDecoratorMetadata = (component) => {
    const decorators = reflectionCapabilities.annotations(component);
    return decorators.reverse().find((d) => d instanceof core_1.Component);
};
